#!/usr/bin/env python3
# -*- mode: python -*-

"""pbench-tool-meister-client

Responsible for publishing the requested tool meister operation.  The
operation can be one of "start", "stop", or "send".
"""

import sys
import json
import logging
import redis
from redis import RedisError

from config import conf
config = conf["tool-meister"]


logger = logging.getLogger(__file__)
logger.setLevel(logging.INFO)
sh = logging.StreamHandler()
sh.setLevel(logging.INFO)
shf = logging.Formatter('%(message)s')
sh.setFormatter(shf)
logger.addHandler(sh)


def main(argv):
    """Main program for the tool meister client.
    """

    try:
        group = argv[1]
    except IndexError:
        raise Exception("Missing group argument")
    try:
        iteration = argv[2]
    except IndexError:
        raise Exception("Missing iteration argument")
    try:
        sample = argv[3]
    except IndexError:
        raise Exception("Missing sample argument")
    try:
        operation = argv[4]
    except IndexError:
        raise Exception("Missing operation argument")
    else:
        operations = config["operations"]
        if operation not in operations:
            raise Exception(f"Unrecognized operation, '{operation}', valid operations are: {operations}")
        elif operation == 'postprocess':
            # We map the legacy "postprocess" action to the new "send" action.
            operation = 'send'
        elif operation == 'kill':
            # FIXME: we need to implement the gritty method of killing all the
            # tool meisters, locally and remotely, and ensuring they are all
            # properly shut down.
            return 0

    redis_host = config["redis_host"]
    redis_port = config["redis_port"]
    try:
        redis_server = redis.Redis(host=redis_host, port=redis_port, db=0)
    except RedisError:
        logger.exception(f"Unable to connect to redis server, {redis_host}:{redis_port}: ")
        return 2

    msg = dict(state=operation, iteration=iteration, sample=sample,
               group=group)
    channel = config["channel"]
    try:
        ret = redis_server.publish(channel, json.dumps(msg))
    except RedisError:
        logger.exception("Failed to publish client message")
    else:
        logger.debug(f"publish() = {ret}")

    return 0


if __name__ == '__main__':
    status = main(sys.argv)
    sys.exit(status)
